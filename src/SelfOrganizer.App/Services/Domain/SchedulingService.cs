using SelfOrganizer.App.Services.Intelligence;
using SelfOrganizer.Core.Interfaces;
using SelfOrganizer.Core.Models;

namespace SelfOrganizer.App.Services.Domain;

public class SchedulingService : ISchedulingService
{
    private readonly IRepository<TimeBlock> _repository;
    private readonly ICalendarService _calendarService;
    private readonly IRepository<UserPreferences> _preferencesRepository;
    private readonly IRepository<CategoryDefinition> _categoryRepository;
    private readonly ITaskOptimizerService _taskOptimizer;

    public SchedulingService(
        IRepository<TimeBlock> repository,
        ICalendarService calendarService,
        IRepository<UserPreferences> preferencesRepository,
        IRepository<CategoryDefinition> categoryRepository,
        ITaskOptimizerService taskOptimizer)
    {
        _repository = repository;
        _calendarService = calendarService;
        _preferencesRepository = preferencesRepository;
        _categoryRepository = categoryRepository;
        _taskOptimizer = taskOptimizer;
    }

    public async Task<IEnumerable<TimeBlock>> GenerateTimeBlocksAsync(DateOnly date)
    {
        var blocks = new List<TimeBlock>();

        // Load all data in parallel for better performance
        var eventsTask = _calendarService.GetEventsForDateAsync(date);
        var preferencesTask = _preferencesRepository.GetAllAsync();
        var categoriesTask = _categoryRepository.GetAllAsync();

        await Task.WhenAll(eventsTask, preferencesTask, categoriesTask);

        var events = await eventsTask;
        var preferences = (await preferencesTask).FirstOrDefault() ?? new UserPreferences();
        var categories = await categoriesTask;

        var workDayStart = date.ToDateTime(TimeOnly.FromTimeSpan(preferences.WorkDayStart));
        var workDayEnd = date.ToDateTime(TimeOnly.FromTimeSpan(preferences.WorkDayEnd));

        // Create blocks for each event
        foreach (var evt in events.OrderBy(e => e.StartTime))
        {
            var category = categories.FirstOrDefault(c => c.Name == evt.EffectiveCategory.ToString());
            var prepMinutes = evt.PrepTimeMinutes ?? category?.DefaultPrepMinutes ?? 5;
            var decompressMinutes = evt.DecompressTimeMinutes ?? category?.DefaultDecompressMinutes ?? 5;

            // Prep block
            if (prepMinutes > 0 && evt.RequiresPrep)
            {
                blocks.Add(new TimeBlock
                {
                    StartTime = evt.StartTime.AddMinutes(-prepMinutes),
                    EndTime = evt.StartTime,
                    Type = TimeBlockType.MeetingPrep,
                    LinkedEventId = evt.Id,
                    IsAutoGenerated = true,
                    Category = evt.EffectiveCategory.ToString()
                });
            }

            // Meeting block
            blocks.Add(new TimeBlock
            {
                StartTime = evt.StartTime,
                EndTime = evt.EndTime,
                Type = TimeBlockType.Meeting,
                LinkedEventId = evt.Id,
                IsAutoGenerated = true,
                Category = evt.EffectiveCategory.ToString()
            });

            // Decompress block
            if (decompressMinutes > 0)
            {
                blocks.Add(new TimeBlock
                {
                    StartTime = evt.EndTime,
                    EndTime = evt.EndTime.AddMinutes(decompressMinutes),
                    Type = TimeBlockType.MeetingDecompress,
                    LinkedEventId = evt.Id,
                    IsAutoGenerated = true,
                    Category = evt.EffectiveCategory.ToString()
                });
            }
        }

        // Identify available slots
        var sortedBlocks = blocks.OrderBy(b => b.StartTime).ToList();
        var availableBlocks = new List<TimeBlock>();
        var currentTime = workDayStart;

        foreach (var block in sortedBlocks)
        {
            if (block.StartTime > currentTime)
            {
                var duration = (block.StartTime - currentTime).TotalMinutes;
                if (duration >= preferences.MinimumUsableBlockMinutes)
                {
                    availableBlocks.Add(new TimeBlock
                    {
                        StartTime = currentTime,
                        EndTime = block.StartTime,
                        Type = duration >= preferences.DeepWorkMinimumMinutes
                            ? TimeBlockType.DeepWork
                            : TimeBlockType.ShallowWork,
                        IsAutoGenerated = true
                    });
                }
            }
            currentTime = block.EndTime > currentTime ? block.EndTime : currentTime;
        }

        // Check for remaining time after last block
        if (currentTime < workDayEnd)
        {
            var duration = (workDayEnd - currentTime).TotalMinutes;
            if (duration >= preferences.MinimumUsableBlockMinutes)
            {
                availableBlocks.Add(new TimeBlock
                {
                    StartTime = currentTime,
                    EndTime = workDayEnd,
                    Type = duration >= preferences.DeepWorkMinimumMinutes
                        ? TimeBlockType.DeepWork
                        : TimeBlockType.ShallowWork,
                    IsAutoGenerated = true
                });
            }
        }

        blocks.AddRange(availableBlocks);
        return blocks.OrderBy(b => b.StartTime);
    }

    public async Task<IEnumerable<TimeBlock>> GetTimeBlocksForDateAsync(DateOnly date)
    {
        var startOfDay = date.ToDateTime(TimeOnly.MinValue);
        var endOfDay = date.ToDateTime(TimeOnly.MaxValue);

        return await _repository.QueryAsync(b =>
            b.StartTime >= startOfDay && b.StartTime <= endOfDay);
    }

    public async Task<TimeBlock> CreateTimeBlockAsync(TimeBlock timeBlock)
    {
        return await _repository.AddAsync(timeBlock);
    }

    public async Task<TimeBlock> UpdateTimeBlockAsync(TimeBlock timeBlock)
    {
        return await _repository.UpdateAsync(timeBlock);
    }

    public async Task DeleteTimeBlockAsync(Guid id)
    {
        await _repository.DeleteAsync(id);
    }

    public async Task<IEnumerable<TimeBlock>> AutoScheduleTasksAsync(DateOnly date, IEnumerable<TodoTask> tasks)
    {
        var preferences = (await _preferencesRepository.GetAllAsync()).FirstOrDefault() ?? new UserPreferences();
        var categories = (await _categoryRepository.GetAllAsync()).ToList();
        var events = (await _calendarService.GetEventsForDateAsync(date)).ToList();

        var workDayStart = date.ToDateTime(TimeOnly.FromTimeSpan(preferences.WorkDayStart));
        var workDayEnd = date.ToDateTime(TimeOnly.FromTimeSpan(preferences.WorkDayEnd));

        // If scheduling for today, start from current time (rounded to next 15-min slot)
        // This ensures we find the NEXT available slot, not the start of the day
        var now = DateTime.Now;
        if (date == DateOnly.FromDateTime(now) && now > workDayStart)
        {
            // Round up to next 15-minute increment
            var minutes = now.Minute;
            var roundedMinutes = ((minutes / 15) + 1) * 15;
            if (roundedMinutes >= 60)
            {
                workDayStart = new DateTime(now.Year, now.Month, now.Day, now.Hour + 1, roundedMinutes - 60, 0);
            }
            else
            {
                workDayStart = new DateTime(now.Year, now.Month, now.Day, now.Hour, roundedMinutes, 0);
            }

            // If we've already passed work day end, no scheduling possible
            if (workDayStart >= workDayEnd)
            {
                return Enumerable.Empty<TimeBlock>();
            }
        }

        // Build a complete list of ALL blocked time ranges (events + prep + decompress)
        var blockedRanges = new List<(DateTime Start, DateTime End)>();
        foreach (var evt in events)
        {
            var category = categories.FirstOrDefault(c => c.Name == evt.EffectiveCategory.ToString());
            var prepMinutes = evt.PrepTimeMinutes ?? category?.DefaultPrepMinutes ?? 0;
            var decompressMinutes = evt.DecompressTimeMinutes ?? category?.DefaultDecompressMinutes ?? 5;

            // Block prep time (if event requires prep)
            if (prepMinutes > 0 && evt.RequiresPrep)
            {
                blockedRanges.Add((evt.StartTime.AddMinutes(-prepMinutes), evt.StartTime));
            }

            // Block the event itself
            blockedRanges.Add((evt.StartTime, evt.EndTime));

            // Block decompress time
            if (decompressMinutes > 0)
            {
                blockedRanges.Add((evt.EndTime, evt.EndTime.AddMinutes(decompressMinutes)));
            }
        }

        // Merge overlapping blocked ranges to simplify available time calculation
        var mergedBlockedRanges = MergeOverlappingRanges(blockedRanges);

        // Calculate truly available time slots (gaps between blocked ranges within work hours)
        var availableSlots = new List<(DateTime Start, DateTime End)>();
        var currentTime = workDayStart;

        foreach (var blocked in mergedBlockedRanges.OrderBy(r => r.Start))
        {
            // Skip blocks entirely before work day
            if (blocked.End <= workDayStart)
                continue;

            // Stop if we've reached end of work day
            if (blocked.Start >= workDayEnd)
                break;

            // Adjust blocked range to work day bounds
            var blockStart = blocked.Start < workDayStart ? workDayStart : blocked.Start;
            var blockEnd = blocked.End > workDayEnd ? workDayEnd : blocked.End;

            // If there's a gap before this block, it's available
            if (blockStart > currentTime)
            {
                var duration = (blockStart - currentTime).TotalMinutes;
                if (duration >= preferences.MinimumUsableBlockMinutes)
                {
                    availableSlots.Add((currentTime, blockStart));
                }
            }

            // Move current time past this block
            if (blockEnd > currentTime)
            {
                currentTime = blockEnd;
            }
        }

        // Check for remaining time after all blocks
        if (currentTime < workDayEnd)
        {
            var duration = (workDayEnd - currentTime).TotalMinutes;
            if (duration >= preferences.MinimumUsableBlockMinutes)
            {
                availableSlots.Add((currentTime, workDayEnd));
            }
        }

        // Convert available slots to TimeBlocks for scheduling
        var availableBlocks = availableSlots.Select(slot => new TimeBlock
        {
            StartTime = slot.Start,
            EndTime = slot.End,
            Type = (slot.End - slot.Start).TotalMinutes >= preferences.DeepWorkMinimumMinutes
                ? TimeBlockType.DeepWork
                : TimeBlockType.ShallowWork,
            IsAutoGenerated = true
        }).ToList();

        // Build scheduling context
        var recentlyScheduledCategories = new List<string>();
        var recentlyScheduledProjectIds = new List<Guid>();
        var recentlyScheduledTags = new List<string>();
        string? currentStakeholder = null;

        var context = new SchedulingContext
        {
            Preferences = preferences,
            TargetDate = date,
            TargetHour = DateTime.Now.Hour,
            CurrentEnergyLevel = GetEnergyLevelForHour(DateTime.Now.Hour, preferences),
            PreferredContexts = GetContextsForTime(DateTime.Now.Hour, preferences),
            RecentCategories = recentlyScheduledCategories,
            RecentProjectIds = recentlyScheduledProjectIds,
            RecentTags = recentlyScheduledTags,
            CurrentStakeholder = currentStakeholder
        };

        var scoredTasks = _taskOptimizer.OptimizeTasks(tasks, context);
        var scheduledBlocks = new List<TimeBlock>();

        foreach (var scoredTask in scoredTasks)
        {
            var task = scoredTask.Task;
            var taskDuration = task.EstimatedMinutes > 0 ? task.EstimatedMinutes : preferences.DefaultTaskDurationMinutes;

            // Update context for momentum tracking
            if (!string.IsNullOrEmpty(task.Category) && !recentlyScheduledCategories.Contains(task.Category))
                recentlyScheduledCategories.Add(task.Category);
            if (task.ProjectId.HasValue && !recentlyScheduledProjectIds.Contains(task.ProjectId.Value))
                recentlyScheduledProjectIds.Add(task.ProjectId.Value);
            foreach (var tag in task.Tags.Where(t => !recentlyScheduledTags.Contains(t)))
                recentlyScheduledTags.Add(tag);
            if (!string.IsNullOrEmpty(task.WhoFor))
                currentStakeholder = task.WhoFor;

            // Find a suitable available block
            var suitableBlock = FindSuitableBlock(availableBlocks, task, taskDuration, preferences);

            if (suitableBlock != null)
            {
                // Create a NEW block specifically for this task (don't reuse the available block)
                var taskBlock = new TimeBlock
                {
                    StartTime = suitableBlock.StartTime,
                    EndTime = suitableBlock.StartTime.AddMinutes(taskDuration),
                    Type = suitableBlock.Type,
                    IsAutoGenerated = true,
                    AssignedTaskIds = new List<Guid> { task.Id }
                };
                scheduledBlocks.Add(taskBlock);

                // Update the available block to reflect used time
                if (suitableBlock.DurationMinutes > taskDuration)
                {
                    // Shrink the block - task takes the beginning
                    suitableBlock.StartTime = suitableBlock.StartTime.AddMinutes(taskDuration);
                    // Update type based on new duration
                    suitableBlock.Type = suitableBlock.DurationMinutes >= preferences.DeepWorkMinimumMinutes
                        ? TimeBlockType.DeepWork
                        : TimeBlockType.ShallowWork;
                }
                else
                {
                    // Block fully consumed
                    availableBlocks.Remove(suitableBlock);
                }
            }
        }

        // Save only the blocks with scheduled tasks
        foreach (var block in scheduledBlocks)
        {
            await _repository.AddAsync(block);
        }

        // Return all generated blocks for reference
        return scheduledBlocks;
    }

    /// <summary>
    /// Merge overlapping time ranges into non-overlapping ranges
    /// </summary>
    private List<(DateTime Start, DateTime End)> MergeOverlappingRanges(List<(DateTime Start, DateTime End)> ranges)
    {
        if (!ranges.Any()) return new();

        var sorted = ranges.OrderBy(r => r.Start).ToList();
        var merged = new List<(DateTime Start, DateTime End)>();
        var current = sorted[0];

        for (int i = 1; i < sorted.Count; i++)
        {
            if (sorted[i].Start <= current.End)
            {
                // Overlapping or adjacent - extend current
                current = (current.Start, sorted[i].End > current.End ? sorted[i].End : current.End);
            }
            else
            {
                // Gap - save current and start new
                merged.Add(current);
                current = sorted[i];
            }
        }
        merged.Add(current);

        return merged;
    }

    private TimeBlock? FindSuitableBlock(
        List<TimeBlock> availableBlocks,
        TodoTask task,
        int taskDuration,
        UserPreferences preferences)
    {
        // First, try to find blocks that match all criteria
        foreach (var block in availableBlocks)
        {
            if (block.DurationMinutes < taskDuration)
                continue;

            // Deep work tasks need deep work blocks
            if (task.RequiresDeepWork && block.Type != TimeBlockType.DeepWork)
                continue;

            // Check energy match if task has energy requirement
            if (task.EnergyLevel.HasValue)
            {
                var blockHour = block.StartTime.Hour;
                var blockEnergy = GetEnergyLevelForHour(blockHour, preferences);
                var energyDiff = Math.Abs(task.EnergyLevel.Value - blockEnergy);

                // Prefer blocks within 1 energy level
                if (energyDiff <= 1)
                    return block;
            }
            else
            {
                return block;
            }
        }

        // Fallback: find any block that fits duration and deep work requirements
        return availableBlocks.FirstOrDefault(b =>
            b.DurationMinutes >= taskDuration &&
            (!task.RequiresDeepWork || b.Type == TimeBlockType.DeepWork));
    }

    private int GetEnergyLevelForHour(int hour, UserPreferences preferences)
    {
        // Energy curve: peak in morning, dip after lunch, slight recovery in afternoon
        var morningPeak = preferences.MorningEnergyPeak;
        var afternoonPeak = preferences.AfternoonEnergyPeak;

        if (Math.Abs(hour - morningPeak) <= 1)
            return 5; // High energy
        if (Math.Abs(hour - afternoonPeak) <= 1)
            return 4; // Medium-high energy
        if (hour >= 12 && hour <= 14)
            return 2; // Post-lunch dip
        if (hour < 9 || hour > 17)
            return 2; // Early morning or evening
        return 3; // Default medium energy
    }

    private IReadOnlyList<string> GetContextsForTime(int hour, UserPreferences preferences)
    {
        // Suggest contexts based on time of day
        var contexts = new List<string>();

        if (hour >= 9 && hour <= 12)
        {
            contexts.Add("deep-work");
            contexts.Add("creative");
        }
        else if (hour >= 13 && hour <= 15)
        {
            contexts.Add("meetings");
            contexts.Add("collaboration");
        }
        else if (hour >= 15 && hour <= 17)
        {
            contexts.Add("admin");
            contexts.Add("email");
            contexts.Add("shallow-work");
        }

        return contexts;
    }

    public async Task ClearAutoGeneratedBlocksAsync(DateOnly date)
    {
        var blocks = await GetTimeBlocksForDateAsync(date);
        foreach (var block in blocks.Where(b => b.IsAutoGenerated))
        {
            await _repository.DeleteAsync(block.Id);
        }
    }
}
