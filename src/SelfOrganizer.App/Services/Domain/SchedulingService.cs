using SelfOrganizer.App.Services.Intelligence;
using SelfOrganizer.Core.Interfaces;
using SelfOrganizer.Core.Models;

namespace SelfOrganizer.App.Services.Domain;

public class SchedulingService : ISchedulingService
{
    private readonly IRepository<TimeBlock> _repository;
    private readonly ICalendarService _calendarService;
    private readonly IRepository<UserPreferences> _preferencesRepository;
    private readonly IRepository<CategoryDefinition> _categoryRepository;
    private readonly ITaskOptimizerService _taskOptimizer;
    private readonly IGoalService _goalService;
    private readonly IRepository<TodoTask> _taskRepository;

    public SchedulingService(
        IRepository<TimeBlock> repository,
        ICalendarService calendarService,
        IRepository<UserPreferences> preferencesRepository,
        IRepository<CategoryDefinition> categoryRepository,
        ITaskOptimizerService taskOptimizer,
        IGoalService goalService,
        IRepository<TodoTask> taskRepository)
    {
        _repository = repository;
        _calendarService = calendarService;
        _preferencesRepository = preferencesRepository;
        _categoryRepository = categoryRepository;
        _taskOptimizer = taskOptimizer;
        _goalService = goalService;
        _taskRepository = taskRepository;
    }

    public async Task<IEnumerable<TimeBlock>> GenerateTimeBlocksAsync(DateOnly date)
    {
        var blocks = new List<TimeBlock>();

        // Load all data in parallel for better performance
        var eventsTask = _calendarService.GetEventsForDateAsync(date);
        var preferencesTask = _preferencesRepository.GetAllAsync();
        var categoriesTask = _categoryRepository.GetAllAsync();

        await Task.WhenAll(eventsTask, preferencesTask, categoriesTask);

        var events = await eventsTask;
        var preferences = (await preferencesTask).FirstOrDefault() ?? new UserPreferences();
        var categories = await categoriesTask;

        var workDayStart = date.ToDateTime(TimeOnly.FromTimeSpan(preferences.WorkDayStart));
        var workDayEnd = date.ToDateTime(TimeOnly.FromTimeSpan(preferences.WorkDayEnd));

        // Create blocks for each event
        foreach (var evt in events.OrderBy(e => e.StartTime))
        {
            var category = categories.FirstOrDefault(c => c.Name == evt.EffectiveCategory.ToString());
            var prepMinutes = evt.PrepTimeMinutes ?? category?.DefaultPrepMinutes ?? 5;
            var decompressMinutes = evt.DecompressTimeMinutes ?? category?.DefaultDecompressMinutes ?? 5;

            // Prep block
            if (prepMinutes > 0 && evt.RequiresPrep)
            {
                blocks.Add(new TimeBlock
                {
                    StartTime = evt.StartTime.AddMinutes(-prepMinutes),
                    EndTime = evt.StartTime,
                    Type = TimeBlockType.MeetingPrep,
                    LinkedEventId = evt.Id,
                    IsAutoGenerated = true,
                    Category = evt.EffectiveCategory.ToString()
                });
            }

            // Meeting block
            blocks.Add(new TimeBlock
            {
                StartTime = evt.StartTime,
                EndTime = evt.EndTime,
                Type = TimeBlockType.Meeting,
                LinkedEventId = evt.Id,
                IsAutoGenerated = true,
                Category = evt.EffectiveCategory.ToString()
            });

            // Decompress block
            if (decompressMinutes > 0)
            {
                blocks.Add(new TimeBlock
                {
                    StartTime = evt.EndTime,
                    EndTime = evt.EndTime.AddMinutes(decompressMinutes),
                    Type = TimeBlockType.MeetingDecompress,
                    LinkedEventId = evt.Id,
                    IsAutoGenerated = true,
                    Category = evt.EffectiveCategory.ToString()
                });
            }
        }

        // Identify available slots
        var sortedBlocks = blocks.OrderBy(b => b.StartTime).ToList();
        var availableBlocks = new List<TimeBlock>();
        var currentTime = workDayStart;

        foreach (var block in sortedBlocks)
        {
            if (block.StartTime > currentTime)
            {
                var duration = (block.StartTime - currentTime).TotalMinutes;
                if (duration >= preferences.MinimumUsableBlockMinutes)
                {
                    availableBlocks.Add(new TimeBlock
                    {
                        StartTime = currentTime,
                        EndTime = block.StartTime,
                        Type = duration >= preferences.DeepWorkMinimumMinutes
                            ? TimeBlockType.DeepWork
                            : TimeBlockType.ShallowWork,
                        IsAutoGenerated = true
                    });
                }
            }
            currentTime = block.EndTime > currentTime ? block.EndTime : currentTime;
        }

        // Check for remaining time after last block
        if (currentTime < workDayEnd)
        {
            var duration = (workDayEnd - currentTime).TotalMinutes;
            if (duration >= preferences.MinimumUsableBlockMinutes)
            {
                availableBlocks.Add(new TimeBlock
                {
                    StartTime = currentTime,
                    EndTime = workDayEnd,
                    Type = duration >= preferences.DeepWorkMinimumMinutes
                        ? TimeBlockType.DeepWork
                        : TimeBlockType.ShallowWork,
                    IsAutoGenerated = true
                });
            }
        }

        blocks.AddRange(availableBlocks);
        return blocks.OrderBy(b => b.StartTime);
    }

    public async Task<IEnumerable<TimeBlock>> GetTimeBlocksForDateAsync(DateOnly date)
    {
        var startOfDay = date.ToDateTime(TimeOnly.MinValue);
        var endOfDay = date.ToDateTime(TimeOnly.MaxValue);

        return await _repository.QueryAsync(b =>
            b.StartTime >= startOfDay && b.StartTime <= endOfDay);
    }

    public async Task<TimeBlock> CreateTimeBlockAsync(TimeBlock timeBlock)
    {
        ArgumentNullException.ThrowIfNull(timeBlock);
        return await _repository.AddAsync(timeBlock);
    }

    public async Task<TimeBlock> UpdateTimeBlockAsync(TimeBlock timeBlock)
    {
        ArgumentNullException.ThrowIfNull(timeBlock);
        return await _repository.UpdateAsync(timeBlock);
    }

    public async Task DeleteTimeBlockAsync(Guid id)
    {
        await _repository.DeleteAsync(id);
    }

    public async Task<IEnumerable<TimeBlock>> AutoScheduleTasksAsync(DateOnly date, IEnumerable<TodoTask> tasks)
    {
        ArgumentNullException.ThrowIfNull(tasks);
        var preferences = (await _preferencesRepository.GetAllAsync()).FirstOrDefault() ?? new UserPreferences();
        var categories = (await _categoryRepository.GetAllAsync()).ToList();
        var events = (await _calendarService.GetEventsForDateAsync(date)).ToList();

        var workDayStart = date.ToDateTime(TimeOnly.FromTimeSpan(preferences.WorkDayStart));
        var workDayEnd = date.ToDateTime(TimeOnly.FromTimeSpan(preferences.WorkDayEnd));

        // If scheduling for today, start from current time (rounded to next 15-min slot)
        // This ensures we find the NEXT available slot, not the start of the day
        var now = DateTime.Now;
        if (date == DateOnly.FromDateTime(now) && now > workDayStart)
        {
            // Round up to next 15-minute increment
            var minutes = now.Minute;
            var roundedMinutes = ((minutes / 15) + 1) * 15;
            if (roundedMinutes >= 60)
            {
                workDayStart = new DateTime(now.Year, now.Month, now.Day, now.Hour + 1, roundedMinutes - 60, 0);
            }
            else
            {
                workDayStart = new DateTime(now.Year, now.Month, now.Day, now.Hour, roundedMinutes, 0);
            }

            // If we've already passed work day end, no scheduling possible
            if (workDayStart >= workDayEnd)
            {
                return Enumerable.Empty<TimeBlock>();
            }
        }

        // Build a complete list of ALL blocked time ranges (events + prep + decompress)
        var blockedRanges = new List<(DateTime Start, DateTime End)>();
        foreach (var evt in events)
        {
            var category = categories.FirstOrDefault(c => c.Name == evt.EffectiveCategory.ToString());
            var prepMinutes = evt.PrepTimeMinutes ?? category?.DefaultPrepMinutes ?? 0;
            var decompressMinutes = evt.DecompressTimeMinutes ?? category?.DefaultDecompressMinutes ?? 5;

            // Block prep time (if event requires prep)
            if (prepMinutes > 0 && evt.RequiresPrep)
            {
                blockedRanges.Add((evt.StartTime.AddMinutes(-prepMinutes), evt.StartTime));
            }

            // Block the event itself
            blockedRanges.Add((evt.StartTime, evt.EndTime));

            // Block decompress time
            if (decompressMinutes > 0)
            {
                blockedRanges.Add((evt.EndTime, evt.EndTime.AddMinutes(decompressMinutes)));
            }
        }

        // Merge overlapping blocked ranges to simplify available time calculation
        var mergedBlockedRanges = MergeOverlappingRanges(blockedRanges);

        // Calculate truly available time slots (gaps between blocked ranges within work hours)
        var availableSlots = new List<(DateTime Start, DateTime End)>();
        var currentTime = workDayStart;

        foreach (var blocked in mergedBlockedRanges.OrderBy(r => r.Start))
        {
            // Skip blocks entirely before work day
            if (blocked.End <= workDayStart)
                continue;

            // Stop if we've reached end of work day
            if (blocked.Start >= workDayEnd)
                break;

            // Adjust blocked range to work day bounds
            var blockStart = blocked.Start < workDayStart ? workDayStart : blocked.Start;
            var blockEnd = blocked.End > workDayEnd ? workDayEnd : blocked.End;

            // If there's a gap before this block, it's available
            if (blockStart > currentTime)
            {
                var duration = (blockStart - currentTime).TotalMinutes;
                if (duration >= preferences.MinimumUsableBlockMinutes)
                {
                    availableSlots.Add((currentTime, blockStart));
                }
            }

            // Move current time past this block
            if (blockEnd > currentTime)
            {
                currentTime = blockEnd;
            }
        }

        // Check for remaining time after all blocks
        if (currentTime < workDayEnd)
        {
            var duration = (workDayEnd - currentTime).TotalMinutes;
            if (duration >= preferences.MinimumUsableBlockMinutes)
            {
                availableSlots.Add((currentTime, workDayEnd));
            }
        }

        // Convert available slots to TimeBlocks for scheduling
        var availableBlocks = availableSlots.Select(slot => new TimeBlock
        {
            StartTime = slot.Start,
            EndTime = slot.End,
            Type = (slot.End - slot.Start).TotalMinutes >= preferences.DeepWorkMinimumMinutes
                ? TimeBlockType.DeepWork
                : TimeBlockType.ShallowWork,
            IsAutoGenerated = true
        }).ToList();

        // Build scheduling context
        var recentlyScheduledCategories = new List<string>();
        var recentlyScheduledProjectIds = new List<Guid>();
        var recentlyScheduledTags = new List<string>();
        string? currentStakeholder = null;

        var context = new SchedulingContext
        {
            Preferences = preferences,
            TargetDate = date,
            TargetHour = DateTime.Now.Hour,
            CurrentEnergyLevel = GetEnergyLevelForHour(DateTime.Now.Hour, preferences),
            PreferredContexts = GetContextsForTime(DateTime.Now.Hour, preferences),
            RecentCategories = recentlyScheduledCategories,
            RecentProjectIds = recentlyScheduledProjectIds,
            RecentTags = recentlyScheduledTags,
            CurrentStakeholder = currentStakeholder
        };

        var scoredTasks = _taskOptimizer.OptimizeTasks(tasks, context);
        var scheduledBlocks = new List<TimeBlock>();

        foreach (var scoredTask in scoredTasks)
        {
            var task = scoredTask.Task;
            var taskDuration = task.EstimatedMinutes > 0 ? task.EstimatedMinutes : preferences.DefaultTaskDurationMinutes;

            // Update context for momentum tracking
            if (!string.IsNullOrEmpty(task.Category) && !recentlyScheduledCategories.Contains(task.Category))
                recentlyScheduledCategories.Add(task.Category);
            if (task.ProjectId.HasValue && !recentlyScheduledProjectIds.Contains(task.ProjectId.Value))
                recentlyScheduledProjectIds.Add(task.ProjectId.Value);
            foreach (var tag in task.Tags.Where(t => !recentlyScheduledTags.Contains(t)))
                recentlyScheduledTags.Add(tag);
            if (!string.IsNullOrEmpty(task.WhoFor))
                currentStakeholder = task.WhoFor;

            // Find a suitable available block
            var suitableBlock = FindSuitableBlock(availableBlocks, task, taskDuration, preferences);

            if (suitableBlock != null)
            {
                // Create a NEW block specifically for this task (don't reuse the available block)
                var taskBlock = new TimeBlock
                {
                    StartTime = suitableBlock.StartTime,
                    EndTime = suitableBlock.StartTime.AddMinutes(taskDuration),
                    Type = suitableBlock.Type,
                    IsAutoGenerated = true,
                    AssignedTaskIds = new List<Guid> { task.Id }
                };
                scheduledBlocks.Add(taskBlock);

                // Update the available block to reflect used time
                if (suitableBlock.DurationMinutes > taskDuration)
                {
                    // Shrink the block - task takes the beginning
                    suitableBlock.StartTime = suitableBlock.StartTime.AddMinutes(taskDuration);
                    // Update type based on new duration
                    suitableBlock.Type = suitableBlock.DurationMinutes >= preferences.DeepWorkMinimumMinutes
                        ? TimeBlockType.DeepWork
                        : TimeBlockType.ShallowWork;
                }
                else
                {
                    // Block fully consumed
                    availableBlocks.Remove(suitableBlock);
                }
            }
        }

        // Save only the blocks with scheduled tasks
        foreach (var block in scheduledBlocks)
        {
            await _repository.AddAsync(block);
        }

        // Return all generated blocks for reference
        return scheduledBlocks;
    }

    /// <summary>
    /// Merge overlapping time ranges into non-overlapping ranges
    /// </summary>
    private List<(DateTime Start, DateTime End)> MergeOverlappingRanges(List<(DateTime Start, DateTime End)> ranges)
    {
        if (!ranges.Any()) return new();

        var sorted = ranges.OrderBy(r => r.Start).ToList();
        var merged = new List<(DateTime Start, DateTime End)>();
        var current = sorted[0];

        for (int i = 1; i < sorted.Count; i++)
        {
            if (sorted[i].Start <= current.End)
            {
                // Overlapping or adjacent - extend current
                current = (current.Start, sorted[i].End > current.End ? sorted[i].End : current.End);
            }
            else
            {
                // Gap - save current and start new
                merged.Add(current);
                current = sorted[i];
            }
        }
        merged.Add(current);

        return merged;
    }

    private TimeBlock? FindSuitableBlock(
        List<TimeBlock> availableBlocks,
        TodoTask task,
        int taskDuration,
        UserPreferences preferences)
    {
        // First, try to find blocks that match all criteria
        foreach (var block in availableBlocks)
        {
            if (block.DurationMinutes < taskDuration)
                continue;

            // Deep work tasks need deep work blocks
            if (task.RequiresDeepWork && block.Type != TimeBlockType.DeepWork)
                continue;

            // Check energy match if task has energy requirement
            if (task.EnergyLevel.HasValue)
            {
                var blockHour = block.StartTime.Hour;
                var blockEnergy = GetEnergyLevelForHour(blockHour, preferences);
                var energyDiff = Math.Abs(task.EnergyLevel.Value - blockEnergy);

                // Prefer blocks within 1 energy level
                if (energyDiff <= 1)
                    return block;
            }
            else
            {
                return block;
            }
        }

        // Fallback: find any block that fits duration and deep work requirements
        return availableBlocks.FirstOrDefault(b =>
            b.DurationMinutes >= taskDuration &&
            (!task.RequiresDeepWork || b.Type == TimeBlockType.DeepWork));
    }

    private int GetEnergyLevelForHour(int hour, UserPreferences preferences)
    {
        // Energy curve: peak in morning, dip after lunch, slight recovery in afternoon
        var morningPeak = preferences.MorningEnergyPeak;
        var afternoonPeak = preferences.AfternoonEnergyPeak;

        if (Math.Abs(hour - morningPeak) <= 1)
            return 5; // High energy
        if (Math.Abs(hour - afternoonPeak) <= 1)
            return 4; // Medium-high energy
        if (hour >= 12 && hour <= 14)
            return 2; // Post-lunch dip
        if (hour < 9 || hour > 17)
            return 2; // Early morning or evening
        return 3; // Default medium energy
    }

    private IReadOnlyList<string> GetContextsForTime(int hour, UserPreferences preferences)
    {
        // Suggest contexts based on time of day
        var contexts = new List<string>();

        if (hour >= 9 && hour <= 12)
        {
            contexts.Add("deep-work");
            contexts.Add("creative");
        }
        else if (hour >= 13 && hour <= 15)
        {
            contexts.Add("meetings");
            contexts.Add("collaboration");
        }
        else if (hour >= 15 && hour <= 17)
        {
            contexts.Add("admin");
            contexts.Add("email");
            contexts.Add("shallow-work");
        }

        return contexts;
    }

    public async Task ClearAutoGeneratedBlocksAsync(DateOnly date)
    {
        var blocks = await GetTimeBlocksForDateAsync(date);
        foreach (var block in blocks.Where(b => b.IsAutoGenerated))
        {
            await _repository.DeleteAsync(block.Id);
        }
    }

    #region Goal-Aware Scheduling

    /// <summary>
    /// Get progress reports for all active goals
    /// </summary>
    public async Task<IEnumerable<GoalProgressReport>> GetGoalProgressReportsAsync()
    {
        var reports = new List<GoalProgressReport>();
        var activeGoals = await _goalService.GetActiveGoalsAsync();
        var allTasks = (await _taskRepository.GetAllAsync()).ToList();

        foreach (var goal in activeGoals)
        {
            var linkedTasks = allTasks
                .Where(t => t.GoalIds.Contains(goal.Id) || goal.LinkedTaskIds.Contains(t.Id))
                .ToList();

            var completedTasks = linkedTasks.Where(t => t.Status == TodoTaskStatus.Completed).ToList();
            var overdueTasks = linkedTasks
                .Where(t => t.DueDate.HasValue && t.DueDate < DateTime.Today && t.Status != TodoTaskStatus.Completed)
                .ToList();
            var upcomingTasks = linkedTasks
                .Where(t => t.Status == TodoTaskStatus.NextAction && t.DueDate.HasValue && t.DueDate >= DateTime.Today)
                .OrderBy(t => t.DueDate)
                .Take(5)
                .ToList();

            var daysRemaining = goal.TargetDate.HasValue
                ? (goal.TargetDate.Value.Date - DateTime.Today).Days
                : 0;

            // Calculate progress based on task completion
            var taskBasedProgress = linkedTasks.Any()
                ? (completedTasks.Count * 100.0 / linkedTasks.Count)
                : goal.ProgressPercent;

            // Use the higher of task-based progress or manual progress
            var progressPercent = Math.Max(taskBasedProgress, goal.ProgressPercent);

            // Calculate required daily progress to stay on track
            var remainingProgress = 100 - progressPercent;
            var requiredDailyProgress = daysRemaining > 0
                ? remainingProgress / daysRemaining
                : remainingProgress;

            // Determine if on track
            var isOnTrack = true;
            string? recommendation = null;

            if (goal.TargetDate.HasValue && goal.StartDate.HasValue)
            {
                var totalDays = (goal.TargetDate.Value - goal.StartDate.Value).TotalDays;
                var elapsedDays = (DateTime.Today - goal.StartDate.Value).TotalDays;
                var expectedProgress = totalDays > 0 ? (elapsedDays / totalDays) * 100 : 0;

                isOnTrack = progressPercent >= expectedProgress - 10; // 10% buffer

                if (!isOnTrack)
                {
                    var behindBy = expectedProgress - progressPercent;
                    recommendation = behindBy > 25
                        ? $"Goal is significantly behind schedule ({behindBy:F0}%). Consider prioritizing goal-related tasks."
                        : $"Goal is slightly behind schedule ({behindBy:F0}%). Focus on completing overdue tasks.";
                }
            }

            if (overdueTasks.Any())
            {
                recommendation = recommendation != null
                    ? $"{recommendation} {overdueTasks.Count} task(s) overdue."
                    : $"You have {overdueTasks.Count} overdue task(s) for this goal.";
            }

            reports.Add(new GoalProgressReport
            {
                Goal = goal,
                ProgressPercent = progressPercent,
                DaysRemaining = daysRemaining,
                RequiredDailyProgress = requiredDailyProgress,
                IsOnTrack = isOnTrack,
                Recommendation = recommendation,
                OverdueTasks = overdueTasks,
                UpcomingTasks = upcomingTasks,
                AllLinkedTasks = linkedTasks,
                TotalTaskCount = linkedTasks.Count,
                CompletedTaskCount = completedTasks.Count
            });
        }

        return reports.OrderByDescending(r => r.RiskLevel).ThenBy(r => r.DaysRemaining);
    }

    /// <summary>
    /// Get tasks linked to a specific goal that are ready for scheduling
    /// </summary>
    public async Task<IEnumerable<TodoTask>> GetGoalSubtasksForSchedulingAsync(Guid goalId)
    {
        var goal = await _goalService.GetByIdAsync(goalId);
        if (goal == null)
            return Enumerable.Empty<TodoTask>();

        var allTasks = await _taskRepository.GetAllAsync();

        return allTasks.Where(t =>
            (t.GoalIds.Contains(goalId) || goal.LinkedTaskIds.Contains(t.Id)) &&
            t.Status == TodoTaskStatus.NextAction &&
            !t.IsBlocked);
    }

    /// <summary>
    /// Auto-schedule tasks with goal awareness - prioritizes tasks linked to at-risk goals
    /// </summary>
    public async Task<IEnumerable<TimeBlock>> AutoScheduleWithGoalAwarenessAsync(
        DateOnly date,
        IEnumerable<TodoTask> tasks,
        IEnumerable<Goal> goals)
    {
        var taskList = tasks.ToList();
        var goalList = goals.ToList();

        // Get goal progress reports to identify at-risk goals
        var goalReports = (await GetGoalProgressReportsAsync()).ToList();
        var atRiskGoalIds = goalReports
            .Where(r => r.RiskLevel >= GoalRiskLevel.Medium || r.OverdueTasks.Any())
            .Select(r => r.Goal.Id)
            .ToHashSet();

        // Boost priority of tasks linked to at-risk goals
        foreach (var task in taskList)
        {
            var isLinkedToAtRiskGoal = task.GoalIds.Any(gid => atRiskGoalIds.Contains(gid));

            if (isLinkedToAtRiskGoal)
            {
                // Temporarily boost priority for scheduling (1 = highest)
                task.Priority = Math.Max(1, task.Priority - 1);
            }
        }

        // Also include tasks directly linked to goals from goal.LinkedTaskIds
        var goalLinkedTaskIds = goalList
            .SelectMany(g => g.LinkedTaskIds)
            .ToHashSet();

        var allTasks = await _taskRepository.GetAllAsync();
        var additionalGoalTasks = allTasks
            .Where(t =>
                goalLinkedTaskIds.Contains(t.Id) &&
                !taskList.Any(existing => existing.Id == t.Id) &&
                t.Status == TodoTaskStatus.NextAction)
            .ToList();

        // Boost priority for at-risk goal tasks
        foreach (var task in additionalGoalTasks)
        {
            var linkedGoal = goalList.FirstOrDefault(g => g.LinkedTaskIds.Contains(task.Id));
            if (linkedGoal != null && atRiskGoalIds.Contains(linkedGoal.Id))
            {
                task.Priority = Math.Max(1, task.Priority - 1);
            }
        }

        taskList.AddRange(additionalGoalTasks);

        // Use existing auto-schedule with the boosted priorities
        return await AutoScheduleTasksAsync(date, taskList);
    }

    #endregion
}
